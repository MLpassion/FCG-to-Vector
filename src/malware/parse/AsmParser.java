package malware.parse;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ml.association.HashTreeItemset;

/***
 * Parser for processing disassembled files.
 * 
 * @author mehadi <mhassen2005@my.fit.edu>
 *
 */
public class AsmParser {
  public enum ExtractionMode {
    INSTRUCTION, TRANSACTION, INSTRUCTION_AND_TRANSACTION
  }
  public enum AsmMode {
    ASM, OPCODE
  }

  public static class Instruction {
    String asm;
    String opcode;
    String calledFunction;
    String operand;

    public Instruction() {
      super();
    }

    public Instruction(String asm, String opcode) {
      this();
      this.asm = asm;
      this.opcode = opcode;
    }

    public String getAsm() {
      return asm;
    }

    public void setAsm(String asm) {
      this.asm = asm;
    }

    public String getOpcode() {
      return opcode;
    }

    public void setOpcode(String opcode) {
      this.opcode = opcode;
    }

    public String getCalledFunction() {
      return calledFunction;
    }

    public void setCalledFunction(String calledFunction) {
      this.calledFunction = calledFunction;
    }

    public String getOperand() {
      return operand;
    }

    public void setOperand(String operand) {
      this.operand = operand;
    }

    @Override
    public String toString() {
      return String.format("%s:%s", opcode, asm);
    }
  }

  /***
   * Regex pattern used to extract asm instruction and opcode from a line in disassembled file.
   * 
   * Or an other option is to combine disAsmLinePattern and twoByteOpecodePattern into one with the
   * following regex.
   * 
   * .text:[0-9A-Fa-f]+\s+((?:0[Ff]\s+)?(?:[0-9A-Fa-f]{2}))\s+(?:[0-9A-Fa-f]{2}\s+)*\s+([a-zA-Z0-9]+)(.*)
   */
  static Pattern disAsmLinePattern =
      Pattern.compile(".text:[0-9A-Fa-f]+\\s+((?:[0-9A-Fa-f][0-9A-Fa-f]\\s)+)\\s+(\\S+)(.*)");

  /***
   * Regex pattern used to extract asm instruction and opcode from a line in disassembled file. In
   * this version DB instructions are not included.
   * 
   * Explanation: ".text:[0-9A-Fa-f]+\\s+" - matchs '.text:0040E759 '
   * "((?:[0-9A-Fa-f][0-9A-Fa-f]\\s)+)(?!\\s+[dD][bwdqtBWDTQ]\\s+)\\s+" - matchs '0F 95 C1 ' EXCEPT
   * when this is followd by db|dd|dw|dq|dt - doesn't match '03 db'
   * "([a-zA-Z][a-zA-Z0-9]{1,8}(?!\\s+[dD][bwdqtBWDTQ]\\s+))" - matchs 'setnz' EXCEPT when this is
   * followd by db|dd|dw|dq|dt "(?:\\s+(.*)|$)" - matchs any characters or end of line.
   * ".text:[0-9A-Fa-f]+\\s+((?:[0-9A-Fa-f][0-9A-Fa-f]\\s)+)\\s+(\\S+)(.*)"
   */
  static Pattern disAsmLinePatternNoDB = Pattern.compile(
      ".text:[0-9A-Fa-f]+\\s+((?:[0-9A-Fa-f][0-9A-Fa-f]\\s)+)(?!\\s+[dD][bwdqtBWDTQ]\\s+)\\s+"
          + "([a-zA-Z][a-zA-Z0-9]{1,12}(?!\\s+[dD][bwdqtBWDTQ]\\s+))" + "(?:\\s+(.*)|$)");
  /***
   * Regex pattern for identifying two byte opcodes.
   */
  static Pattern twoByteOpecodePattern = Pattern.compile("^(0[Ff]\\s+[0-9A-Fa-f]{2}).*");
  /***
   * Regex pattern for identifying the start of function/sub routine.
   */
  static Pattern functionStartPattern =
      Pattern.compile(".text:[0-9A-Fa-f]+\\s+(sub_[0-9A-Fa-f]+)\\s+proc\\s+near.*");
  /***
   * Regex pattern for identifying the end of function/sub routine.
   */
  static Pattern functionEndPattern =
      Pattern.compile(".text:[0-9A-Fa-f]+\\s+(sub_[0-9A-Fa-f]+)\\s+endp.*");
  /***
   * Regex pattern for identifying addrase labels.
   */
  static Pattern locPattern =
      Pattern.compile(".text:[0-9A-Fa-f]+\\s+(loc_[0-9A-Fa-f]+):\\s+;\\s+.*");

  /***
   * Parses the entire disassembled file as transactional data.
   * 
   * @param in - InputStream of the disassembled file.
   * @param mode mode of representing a transaction(using asm or opcode).
   * @param includeDBInstructions If true DB,DW,DD,DQ,DT instrcutions will be included.
   * @return List of transactions represented as itemsets.
   */
  public static List<HashTreeItemset> parseTransaction(InputStream input, AsmMode mode, 
      boolean includeDBInstructions) {
    List<HashTreeItemset> transactions = new ArrayList<HashTreeItemset>(1000);

    Scanner in = new Scanner(input);
    while (in.hasNextLine()) {
      String line = in.nextLine();
      Instruction processingResult = parseAsmLine(line, includeDBInstructions);
      if (processingResult == null) {
        continue;
      }
      // We create one item itemset transactions.
      HashTreeItemset itemset = new HashTreeItemset();
      if (mode == AsmMode.ASM) {
        itemset.addItem(processingResult.getAsm());
      } else {
        itemset.addItem(processingResult.getOpcode());
      }
      transactions.add(itemset);
    }

    return transactions;
  }

  /***
   * Parses the entire disassembled file and returns a list of intructions in the order they appear
   * int the file.
   * 
   * @param input - InputStream of the disassembled file. Preferably, a BufferedInputStream.
   * @param includeDBInstructions If true DB,DW,DD,DQ,DT instrcutions will be included.
   * @return List of intructions.
   */
  public static List<Instruction> parseIntructionList(InputStream input,
      boolean includeDBInstructions) {
    List<Instruction> instList = new ArrayList<>(1000);

    Scanner in = new Scanner(input);
    while (in.hasNextLine()) {
      String line = in.nextLine();
      Instruction inst = parseAsmLine(line, includeDBInstructions);
      if (inst == null) {
        continue;
      }
      instList.add(inst);
    }

    return instList;
  }

  /***
   * Parses a disassembled code to extract a functions(method) based presentation where the 
   * functions are represented as list instructions or list of transactions.
   * 
   * @param input input stream containing the disassembled code.
   * @param mode mode of representing a transaction(using asm or opcode).
   * @param extMode Extraction mode can be instruction onlu, transaction only or both.
   * @param includeDBInstructions If true DB,DW,DD,DQ,DT instrcutions will be included.
   * @return A list of functions found in the input disassembled code.
   */
  public static List<Function> parseFunctionTransaction(InputStream input, ExtractionMode extMode,
      AsmMode mode, boolean includeDBInstructions) {
    List<Function> functions = new LinkedList<>(); // Since we are not expecting to do any random
                                                   // access.
    // start processing one line at a time
    // for each line check if it is the start of a function or end of a function
    // if end close the previously opened function add to list and open a new function
    // all instruction lines pass them to processAsmLine
    Scanner in = new Scanner(input);
    Function currF = new Function();
    int count_unamed = 1;
    currF.setName("unamed_function_" + count_unamed++);
    while (in.hasNextLine()) {
      String line = in.nextLine();
      // Match line with start of a function/sub routine
      Matcher fStart = functionStartPattern.matcher(line);
      if (fStart.matches() && fStart.groupCount() >= 1) {
        if (currF != null && !currF.isEmpty()) {
          // this happens for unnamed function(functions that are not encapsulated in proc...endp)
          // orystem.out.println("IN currF != null && currF.instruction_size() != 0");
          // this happens for unnamed function(functions that are not encapsulated in proc...endp)
          // or for function with missing 'endp'.
          functions.add(currF);
          currF = null;

        }
        currF = new Function(fStart.group(1));
        continue;
      }

      // Match line with end of a function/sub routine
      Matcher fEnd = functionEndPattern.matcher(line);
      if (fEnd.matches() && fEnd.groupCount() >= 1) {
        if (currF != null && !currF.isEmpty()) {
          // this happens for functions encapsulated in proc...endp block.
          functions.add(currF);
          currF = null;
        }
        continue;
      }

      if (currF == null) {
        currF = new Function("unamed_function_" + count_unamed++);
      }

      // Match line to check for assembly instructions.
      Instruction processingResult = parseAsmLine(line, includeDBInstructions);
      if (processingResult == null) {
        Matcher locMatcher = locPattern.matcher(line);
        if (locMatcher.matches()) {
          String match = locMatcher.group(1);
          if (match != null) {
            currF.addNameAlias(match);
          }
        }
        continue;
      }

      if (extMode == ExtractionMode.INSTRUCTION
          || extMode == ExtractionMode.INSTRUCTION_AND_TRANSACTION) {
        currF.addInstruction(processingResult);
      }

      if (extMode == ExtractionMode.TRANSACTION
          || extMode == ExtractionMode.INSTRUCTION_AND_TRANSACTION) {
        HashTreeItemset transaction = new HashTreeItemset();
        if (mode == AsmMode.ASM) {
          transaction.addItem(processingResult.getAsm());
        } else {
          transaction.addItem(processingResult.getOpcode());
        }
        currF.addtransaction(transaction);
      }

      // Recored called functions
      if ("call".equalsIgnoreCase(processingResult.getAsm())
          && processingResult.getOperand() != null) {
        currF.addcalledFunction(processingResult.getOperand());
      }
    }

    if (currF != null && !currF.isEmpty()) {
      // this happens for functions encapsulated in proc...endp block.
      functions.add(currF);
      currF = null;
    }

    return functions;
  }

  /***
   * Process a line from a disassembled file and returns the instruction and opcode pair.
   * 
   * @param line a line from a disassembled file
   * @param includeDBInstructions If true DB,DW,DD,DQ,DT instrcutions will be included.
   * @return Null if line does not have instruction and opcode. Otherwise return an
   */
  protected static Instruction parseAsmLine(String line, boolean includeDBInstructions) {
    Matcher disAsmLineMatcher;
    if (includeDBInstructions) {
      disAsmLineMatcher = disAsmLinePattern.matcher(line);
    } else {
      disAsmLineMatcher = disAsmLinePatternNoDB.matcher(line);
    }

    if (!disAsmLineMatcher.matches()) {
      return null;
    }
    if (disAsmLineMatcher.group(1) == null || disAsmLineMatcher.group(2) == null) {
      return null;
    }

    Matcher twoBOpecodeMatcher = twoByteOpecodePattern.matcher(disAsmLineMatcher.group(1));
    Instruction inst = new Instruction();
    if (twoBOpecodeMatcher.matches() && twoBOpecodeMatcher.groupCount() >= 1) {
      inst.setOpcode(twoBOpecodeMatcher.group(1));
    } else {
      if (disAsmLineMatcher.group(1).length() < 2) {
        return null;
      }
      inst.setOpcode(disAsmLineMatcher.group(1).substring(0, 2));
    }
    inst.setAsm(disAsmLineMatcher.group(2));

    if (inst.getAsm().equalsIgnoreCase("call")) {
      // extract the name of the called function.
      inst.setOperand(parseFunctionName(disAsmLineMatcher.group(3)));
    }

    return inst;
  }

  /***
   * Sould match any of: sub_[0-9A-Fa-F]+ SOMETHING ; Comment containing function prototype)
   * ds:fprintf near ptr VersionOfUpdateOrPlatform+1
   * 
   */
  static Pattern operandAndCommentPattern =
      Pattern.compile("^\\s*((?:[^;\\s]+\\s*)+)(?:;\\s+(.*))*");
  /***
   * Matches strings of the form: sub_09Af3
   */
  static Pattern localFunctionPattern = Pattern.compile("sub_[0-9A-fa-f]+");
  /***
   * Matches strings of the form: dword ptr functionaName near ptr functionaName
   */
  static Pattern callByPointerPattern = Pattern.compile("\\S+\\s+ptr\\s+\\[?([^+\\s]+).*");
  /***
   * Matches strings of the form: ds:functionName fs:functionName
   */
  static Pattern callBySegmentPattern = Pattern.compile("[CDEFGScdefgs]s:(\\S+)");
  /***
   * Matches strings of the form: eax ebx [eax+1] ebp edi rax
   */
  static Pattern callByRegPattern =
      Pattern.compile("^\\[?+([EeRr][ABCDSabcds][IPXipx])(?:\\+[0-9A-Fa-f]+h?)?\\]?\\s*$");
  /***
   * Matches strings of the form: std::exception::exception(char const * const &) GetProcAddress
   * operator new(uint)
   */
  static Pattern commentFunctionName =
      Pattern.compile("\\s*(?:\\w+\\s+)*([^\\s\\(]+)\\([^)]*\\)|^\\s*(\\S+)\\s*$");

  /***
   * Extracts function names from the operand of CALL instruction or the comment attached to the
   * instruction.
   * 
   * @param oprandAndComment String containing operand and comments, if any, for a CALL asm
   *        instruction.
   * @return NULL if can not parse function name. Otherwise, the name of the function that was
   *         called.
   */
  protected static String parseFunctionName(String oprandAndComment) {
    // Case-1: call sub_[0-9A-Fa-F]+ ---handled
    // Case-2: call SOMETHING ; Comment containing function prototype
    // Case-3: call [A-Z][Ss]:(FunctionName)
    // Case-4: call (?:dword|far|near)\\s+ptr\\s+(\[\]) ---handled
    // Case-5: call REGISTER

    Matcher operandCommentMatch = operandAndCommentPattern.matcher(oprandAndComment);
    if (!operandCommentMatch.matches()) {
      return null;
    }
    String operand = operandCommentMatch.group(1);
    String comment = operandCommentMatch.group(2);
    if (operand == null) {
      return null;
    }
    operand.trim();
    if (comment != null) {
      comment.trim();
    }

    Matcher localFunctionMatch = localFunctionPattern.matcher(operand);
    // call sub_[0-9A-Fa-F]+
    if (localFunctionMatch.matches()) {
      return operand;
    } else {
      if (comment == null) {
        // call (dword|far|near) ptr functionName
        Matcher ptrCallMatch = callByPointerPattern.matcher(operand);
        if (ptrCallMatch.matches()) {
          Matcher regCallMatch = callByRegPattern.matcher(ptrCallMatch.group(1));
          if (regCallMatch.matches()) {
            return null;
          }
          return ptrCallMatch.group(1);
        }

        // call ds:functionaName
        Matcher segmentCallMatch = callBySegmentPattern.matcher(operand);
        if (segmentCallMatch.matches()) {
          return segmentCallMatch.group(1);
        }

        // call eax or call [eax+1]
        Matcher regCallMatch = callByRegPattern.matcher(operand);
        if (regCallMatch.matches()) {
          return null;
        }

        return operand;
      } else {
        // Get function name from comment.
        Matcher commentFuncNameMatcher = commentFunctionName.matcher(comment);
        if (commentFuncNameMatcher.matches()) {
          if (commentFuncNameMatcher.group(1) != null) {
            return commentFuncNameMatcher.group(1);
          }
          if (commentFuncNameMatcher.group(2) != null) {
            return commentFuncNameMatcher.group(2);
          }

          return null;
        }
      }
    }

    return null;
  }
}
