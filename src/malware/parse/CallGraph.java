package malware.parse;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import graph.Graph;
import graph.Vertex;
import malware.feature.FeatureExtractor;
import malware.parse.AsmParser.Instruction;
import malware.parse.CallGraph.FunctionVertex.FunctionType;

public class CallGraph<F> extends Graph<CallGraph.FunctionVertex<F>, CallGraph.FunctionCallEdge> {

  // public enum VertexFeatureMode {
  // Hashed_NGram_Freq_Vector,
  // Hashed_Freq_Seq_Freq_Vetor
  // }

  /***
   * Represents a vertex in a Call Graph.
   * 
   * @author mehadi
   *
   * @param <F> The data type of the machine learning feature represeanting a function.
   */
  public static class FunctionVertex<F> implements Vertex {
    public enum FunctionType {
      Internal, External
    }

    F features;
    String fnName;
    FunctionType type;
    List<Instruction> instructions;

    /***
     * Contructor for an internal function.
     * 
     * @param featureVector the feature vector for an internal function.
     * @param type function type internal / external.
     */
    public FunctionVertex(String internalFnName, F features, FunctionType type) {
      super();
      this.features = features;
      this.fnName = internalFnName;
      this.type = type;
    }

    /***
     * Contructor for an external function.
     * 
     * @param externalFnName name of the external function.
     * @param type function type internal / external.
     */
    public FunctionVertex(String externalFnName, FunctionType type) {
      super();
      this.features = null;
      this.fnName = externalFnName;
      this.type = type;
    }

    public F getFeatures() {
      return features;
    }

    public void setFeatures(F features) {
      this.features = features;
    }

    public String getFnName() {
      return fnName;
    }

    public void setFnName(String fnName) {
      this.fnName = fnName;
    }

    public FunctionType getType() {
      return type;
    }

    public void setType(FunctionType type) {
      this.type = type;
    }

    public String toString() {
      return fnName;
    }

    public void setInstructions(List<Instruction> instuctionList) {
      this.instructions = instuctionList;
    }

    public List<Instruction> getInstructions() {
      return this.instructions;
    }

    @Override
    public String getLabel() {
      return getFnName();
    }
  }

  public static class FunctionCallEdge {
    int caller; // from
    int callee; // to

    public FunctionCallEdge(int caller, int callee) {
      super();
      this.caller = caller;
      this.callee = callee;
    }

    public int getCaller() {
      return caller;
    }

    public int getCallee() {
      return callee;
    }

    public String toString() {
      return String.format("(%d,%d)", caller, callee);
    }

    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + callee;
      result = prime * result + caller;
      return result;
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj) return true;
      if (obj == null) return false;
      if (getClass() != obj.getClass()) return false;
      FunctionCallEdge other = (FunctionCallEdge) obj;

      return (callee == other.callee) && (caller == other.caller);
    }
  }

  String name;

  public CallGraph(int initialCapacityV) {
    super(initialCapacityV);
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  /***
   * Build call graoh from another input call graph with vertex feature int form of an instruction
   * list
   * 
   * @param inputGraph an input call graph with vertex feature in the form of an instruction
   * list
   * @param extractor Feature extractor.
   * @return
   */
  public static <F> CallGraph<F> build(CallGraph<List<Instruction>> inputGraph,
      FeatureExtractor<F, List<AsmParser.Instruction>> extractor) {
    // Initialize Graph
    CallGraph<F> outputGraph = new CallGraph<F>(inputGraph.vSize());
    
    // Travese the vertices in the input graph, create coresponding vertex inputpit graph
    // and extract features.
    for (int vId : inputGraph.getVertices()) {
      FunctionVertex<List<Instruction>> inputVertex = inputGraph.getVertex(vId);
      
      FunctionVertex<F> vertex;
      if (inputVertex.getType() == FunctionType.Internal) {
        F features = extractor.extractFeatures(inputVertex.getFeatures());
        vertex = new FunctionVertex<F>(inputVertex.getFnName(), features, inputVertex.getType());
      } else {
        vertex = new FunctionVertex<F>(inputVertex.getFnName(), inputVertex.getType());
      }
      
      outputGraph.addVertexWithID(vId, vertex);
    }
    
    // Add all the edges in the input graph to the output graph.
    for (int caller : inputGraph.getVertices()) {
      for (int callee : inputGraph.getAdjacent(caller)) {
        outputGraph.addEdge(caller, callee, new FunctionCallEdge(caller, callee));
      }
    }
    
    return outputGraph;
  }

  /***
   * Builds a CallGraph object.
   * 
   * @param functions List of functions.
   * @param extractor Feature extractor.
   * @return a CallGraph.
   */
  public static <F> CallGraph<F> build(List<Function> functions,
      FeatureExtractor<F, List<AsmParser.Instruction>> extractor, boolean saveIntructions) {
    // Initialize Graph
    CallGraph<F> callGraph = new CallGraph<F>(functions.size());

    // Create Lookup table mapping function names to function index.
    Map<String, Integer> nameToFnIndexMap = new HashMap<String, Integer>();

    // Convert all functions to feature vectors.
    for (int i = 0; i < functions.size(); i++) {
      F features = extractor.extractFeatures(functions.get(i).getInstructions());

      FunctionVertex<F> vertex =
          new FunctionVertex<F>(functions.get(i).getName(), features, FunctionType.Internal);
      if (saveIntructions) {
        vertex.setInstructions(functions.get(i).getInstructions());
      }
      int vID = callGraph.addVertex(vertex);
      nameToFnIndexMap.put(functions.get(i).getName(), vID);
      for (String alias : functions.get(i).getNameAlias()) {
        nameToFnIndexMap.put(alias, vID);
      }
    }

    // Identify all the external functions. Add them to the call graph.
    for (int i = 0; i < functions.size(); i++) {
      for (String calledFn : functions.get(i).called()) {
        if (nameToFnIndexMap.containsKey(calledFn)) {
          continue;
        }
        if (!nameToFnIndexMap.containsKey(calledFn)) {
          int vID = callGraph.addVertex(new FunctionVertex<F>(calledFn, FunctionType.External));
          nameToFnIndexMap.put(calledFn, vID);
        }
      }
    }

    // Resolve the function call to an internal or an external function.
    for (int i = 0; i < functions.size(); i++) {
      int caller = nameToFnIndexMap.get(functions.get(i).getName());
      for (String calledFn : functions.get(i).called()) {
        Integer callee = nameToFnIndexMap.get(calledFn);
        if (callee == null) {
          System.out.printf("WARNING: Called function '%s' by function '%s' not found.\n", calledFn,
              functions.get(i).getName());
          continue;
        }
        callGraph.addEdge(caller, callee, new FunctionCallEdge(caller, callee));
      }
    }

    return callGraph;
  }
}
