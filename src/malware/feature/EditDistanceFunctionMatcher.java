package malware.feature;

import java.util.List;

import malware.parse.AsmParser;
import malware.parse.AsmParser.AsmMode;
import malware.parse.AsmParser.Instruction;

public class EditDistanceFunctionMatcher implements FunctionMatcher<List<Instruction>> {
  private AsmMode mode;

  public EditDistanceFunctionMatcher(AsmParser.AsmMode mode) {
    this.mode = mode;
  }

  @Override
  public boolean matching(List<Instruction> function1Feature, List<Instruction> function2Feature,
      float threashold) {
    double editSimilarity = similarity(function1Feature, function2Feature);
    return editSimilarity < threashold;
  }

  @Override
  public double similarity(List<Instruction> function1Feature, List<Instruction> function2Feature) {
    return 1 - editDistance(function1Feature, function2Feature);
  }

  private double editDistance(List<Instruction> inst1, List<Instruction> inst2) {
    int maxLen = Math.max(inst1.size(), inst2.size());
    if (maxLen == 0) {
      return 0.0;
    }
    if (Math.min(inst1.size(), inst2.size()) == 0) {
      return 1;  // = maxLen / maxLen;
    }

    int[][] dist = new int[inst1.size() + 1][inst2.size() + 1];
    for (int i = 0; i < dist.length; i++) {
      dist[i] = new int[inst2.size() + 1];
    }

    for (int i = 0; i < dist.length; i++) {
      dist[i][0] = i;
    }
    for (int j = 0; j < dist[0].length; j++) {
      dist[0][j] = j;
    }

    for (int i = 1; i < dist.length; i++) {
      for (int j = 1; j < dist[i].length; j++) {
        if (mode == AsmMode.ASM) {
          if (inst1.get(i - 1).getAsm().equals(inst2.get(j - 1).getAsm())) {
            dist[i][j] = dist[i - 1][j - 1];
          } else {
            // Currently we assume inser, delete and substitute operation have equal cost of 1.
            dist[i][j] =
                Math.min(dist[i - 1][j] + 1, Math.min(dist[i][j - 1] + 1, dist[i - 1][j - 1] + 1));
          }
        } else {
          if (inst1.get(i - 1).getOpcode().equals(inst2.get(j - 1).getOpcode())) {
            dist[i][j] = dist[i - 1][j - 1];
          } else {
            // Currently we assume inser, delete and substitute operation have equal cost of 1.
            dist[i][j] =
                Math.min(dist[i - 1][j] + 1, Math.min(dist[i][j - 1] + 1, dist[i - 1][j - 1] + 1));
          }
        }
      }
    }

    int eDist = dist[inst1.size()][inst2.size()];

    return (double) eDist / maxLen;
  }

}
