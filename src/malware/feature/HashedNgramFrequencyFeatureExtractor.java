package malware.feature;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import malware.parse.AsmParser;
import malware.parse.Function;
import malware.parse.AsmParser.AsmMode;
import malware.parse.AsmParser.Instruction;
import util.hash.HashFunction;

public class HashedNgramFrequencyFeatureExtractor
    implements
      FeatureExtractor<Double[], List<AsmParser.Instruction>> {
  private int binSize;
  private int ngramLength; // ngram length
  private boolean normalizeVector;
  private HashFunction hashFn;
  private AsmMode asmMode;

  public HashedNgramFrequencyFeatureExtractor(int numHashBits, int ngramLength,
      boolean normalizeVector, AsmMode asmMode, HashFunction hashFn) {
    this.ngramLength = ngramLength;
    this.normalizeVector = normalizeVector;
    this.hashFn = hashFn;
    binSize = (int) Math.pow(2, numHashBits);
    this.asmMode = asmMode;
  }

  @Override
  public Double[] extractFeatures(List<AsmParser.Instruction> instructionList) {
    Double[] featVector = new Double[binSize];
    for (int i = 0; i < featVector.length; i++) {
      featVector[i] = new Double(0);
    }

    Queue<Instruction> slidingW = new LinkedList<Instruction>();
    Iterable<Instruction> asmList = instructionList;

    int count = 0;
    for (Instruction inst : asmList) {
      if (slidingW.size() == ngramLength) {
        int binIndex = binIndex(slidingW);
        featVector[binIndex]++;
        count++;
      }
      slidingW.add(inst);
      if (slidingW.size() > ngramLength) {
        slidingW.poll();
      }
    }
    if (slidingW.size() == ngramLength) {
      int binIndex = binIndex(slidingW);
      featVector[binIndex]++;
      count++;
    }

    for (int i = 0; i < featVector.length; i++) {
      featVector[i] = count == 0 ? 0F : featVector[i] / count;
    }

    if (normalizeVector) {
      normalize(featVector);
    }

    return featVector;
  }

  /***
   * Normalizes to a unit vector.
   * 
   * @param featVector
   */
  private void normalize(Double[] featVector) {
    Double mag = magnitude(featVector);
    for (int i = 0; i < featVector.length; i++) {
      featVector[i] = mag == 0.0 ? 0.0 : featVector[i] / mag;
    }
  }

  /***
   * Calculate magnitude of the vector.
   * 
   * @param featVector input vector.
   * @return magnitude of featVector.
   */
  private double magnitude(Double[] featVector) {
    Double mag = 0.0;
    for (int i = 0; i < featVector.length; i++) {
      mag += featVector[i] * featVector[i];
    }
    return Math.sqrt(mag);
  }

  /***
   * Returns index of the bin the given input hashes to.
   * 
   * @param slidingW
   * @return index of the bin the given input hashes to. The value ranges [0, binSize-1].
   */
  private int binIndex(Queue<Instruction> slidingW) {
    StringBuilder sb = new StringBuilder();
    for (Instruction i : slidingW) {
      if (asmMode == AsmMode.ASM) {
        sb.append(i.getAsm());
      } else {
        sb.append(i.getOpcode());
      }
      sb.append(",");
    }

    int index = hashFn.hash(sb, 0, sb.length()) % binSize;

    return Math.abs(index);
  }

}
