package malware.feature;

import java.util.BitSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import malware.parse.AsmParser;
import malware.parse.Function;
import malware.parse.AsmParser.AsmMode;
import malware.parse.AsmParser.Instruction;
import util.hash.HashFunction;

public class HashedNgramBooleanFeatureExtractor
    implements
      FeatureExtractor<BitSet, List<AsmParser.Instruction>> {
  private int binSize;
  private int ngramLength; // ngram length
  private HashFunction hashFn;
  private AsmMode asmMode;

  public HashedNgramBooleanFeatureExtractor(int numHashBits, int ngramLength, AsmMode asmMode,
      HashFunction hashFn) {
    this.ngramLength = ngramLength;
    this.hashFn = hashFn;
    binSize = (int) Math.pow(2, numHashBits);
    this.asmMode = asmMode;
  }

  @Override
  public BitSet extractFeatures(List<AsmParser.Instruction> instructionList) {
    BitSet featBitVector = new BitSet(binSize);

    Queue<Instruction> slidingW = new LinkedList<Instruction>();
    Iterable<Instruction> asmList = instructionList;

    for (Instruction inst : asmList) {
      if (slidingW.size() == ngramLength) {
        int binIndex = binIndex(slidingW);
        featBitVector.set(binIndex);
      }
      slidingW.add(inst);
      if (slidingW.size() > ngramLength) {
        slidingW.poll();
      }
    }

    if (slidingW.size() == ngramLength) {
      int binIndex = binIndex(slidingW);
      featBitVector.set(binIndex);
    }

    return featBitVector;
  }

  /***
   * Returns index of the bin the given input hashes to.
   * 
   * @param slidingW
   * @return index of the bin the given input hashes to. The value ranges [0, binSize-1].
   */
  private int binIndex(Queue<Instruction> slidingW) {
    StringBuilder sb = new StringBuilder();
    for (Instruction i : slidingW) {
      if (asmMode == AsmMode.ASM) {
        sb.append(i.getAsm());
      } else {
        sb.append(i.getOpcode());
      }
      sb.append(",");
    }

    int index = hashFn.hash(sb, 0, sb.length()) % binSize;

    return Math.abs(index);
  }
}
