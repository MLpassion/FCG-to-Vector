package malware.experiments;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import malware.data.MicrosoftDatasetReaders;
import malware.parse.AsmParser;
import malware.parse.Binary;
import malware.parse.Function;
import malware.parse.AsmParser.AsmMode;
import malware.parse.AsmParser.ExtractionMode;
import ml.association.ItemSet;
import ml.association.HashTreeItemset;
import ml.association.SPAMFrequentItemset;
import ml.association.Sequence;
import util.CommandLineArguments;
import util.FileUtil;

/***
 * Pre-process disassembled binary files and convert them into format for further Machine Learning
 * procedures.
 * 
 * @author Mehadi <mhassen2005@my.fit.edu>
 *
 */
public class AsmPreProcessesor {

  public static void main(String[] args) throws IOException {
    // TODO CommandLineArguments needs support for default value and help string.
    CommandLineArguments cmdArgs = new CommandLineArguments();
    cmdArgs.addOption(false, "-ext", true); // Process files with this extension.
    cmdArgs.addOption(false, "-func_mode", false); // Enable function mode.
    cmdArgs.addOption(true, "-in", true); // Input directory.
    cmdArgs.addOption(false, "-label", true); // Class label file path.
    cmdArgs.addOption(false, "-id_col", false); // Include id column..
    cmdArgs.addOption(true, "-max", true); // Max number of files to process.
    cmdArgs.addOption(false, "-minsup", true); // Minimum support for frequent sequence mining.
    cmdArgs.addOption(false, "-max_len", true); // Max sequence length.
    cmdArgs.addOption(false, "-min_len", true); // Min sequence length.
    cmdArgs.addOption(false, "-gap", true); // Num of gaps allowed between elements of a sequence.
    cmdArgs.addOption(true, "-out", true); // Output file path.
    cmdArgs.addOption(false, "-verbose", true); // Verbose level . 0=no verbose comments.

    if (!cmdArgs.parseCommandLineArgs(args)) {
      System.out.println("Usage:\n\tjava AsmPreProcessesor "
          + " -in input_directory [-label class_label_file]-out output_filepath -max max_num_files "
          + "[-func_mode] [-ext file_extension] [-minsup minimum_spportValue(default=0.07)]"
          + "[-min_len minimum_sequence-length(default=0)]"
          + "[-maxn_len minimum_sequence-length(default=3)]\n" + "[-id_col]\n" + ""
          + "\t\t-in data input directory.\n" + "\t\t-label. Optional\n"
          + "\t\t-out file path of ourput file.\n" + "\t\t-max Max number of files to process.\n"
          + "\t\t-func_mode Enable function mode preprocessing [Optional arg].\n"
          + "\t\t-ext Process files with this extension.\n" + "\t\t-id_col include id column.\n"
          + "\t\t-label Class label file path.\n" + "\t\t-max Max number of files to process.\n"
          + "\t\t-minsup Minimum support for frequent sequence mining.(default=0.07)\n"
          + "\t\t-min_len Minimum length of a sequence(interms of number of itemsets).(default=0)\n"
          + "\t\t-max_len Maximum length of a sequence(interms of number of itemsets).(default=3)\n"
          + "\t\t-gap Number of gaps allowed between elements of a sequence.\n"
          + "\t\t-verbose Verbose level . [default = 0 which means no verbose comments.]");
      return;
    }

    final String inDirPath = cmdArgs.getOptionValue("-in");
    final String classLabelPath = cmdArgs.getOptionValue("-label");
    final String outputFilePath = cmdArgs.getOptionValue("-out");
    final int maxFiles = Integer.parseInt(cmdArgs.getOptionValue("-max"));
    final boolean funcMode = cmdArgs.getOptionValue("-func_mode") == null ? false : true;
    final String extension =
        cmdArgs.getOptionValue("-ext") == null ? null : cmdArgs.getOptionValue("-ext");
    final boolean idCol = cmdArgs.getOptionValue("-id_col") == null ? false : true;
    final double minSup = cmdArgs.getOptionValue("-minsup") == null ? 0.07
        : Double.parseDouble(cmdArgs.getOptionValue("-minsup"));
    final int minSeqLen = cmdArgs.getOptionValue("-min_len") == null ? 0
        : Integer.parseInt(cmdArgs.getOptionValue("-min_len"));
    final int maxSeqLen = cmdArgs.getOptionValue("-max_len") == null ? 3
        : Integer.parseInt(cmdArgs.getOptionValue("-max_len"));
    final int gap = cmdArgs.getOptionValue("-gap") == null ? SPAMFrequentItemset.ALL_GAPS
        : Integer.parseInt(cmdArgs.getOptionValue("-gap"));
    final int verbose = cmdArgs.getOptionValue("-verbose") == null ? SPAMFrequentItemset.LEVEL_0
        : Integer.parseInt(cmdArgs.getOptionValue("-verbose"));

    // List directory content
    File inDir = new File(inDirPath);
    if (!inDir.exists()) {
      System.err.printf("Input directory '%s' does not exist!\n", inDirPath);
      return;
    }

    File classLabelFile = null;
    if (classLabelPath != null) {
      classLabelFile = new File(classLabelPath);
      if (!classLabelFile.exists()) {
        System.err.printf("Class Label File '%s' does not exist!\n", inDirPath);
        return;
      }
    }

    if (funcMode) {
      System.err.println("Function mode currently not supported!!");
      functionFrequentSequence(maxFiles, extension, minSup, minSeqLen, maxSeqLen, gap, inDir,
          classLabelFile, outputFilePath, idCol, verbose);
      return;
    } else {
      binaryFrequentSequence(maxFiles, extension, minSup, minSeqLen, maxSeqLen, gap, inDir,
          classLabelFile, outputFilePath, idCol, verbose);
    }
  }

  /***
   * Extracts call graph representation of a malware.
   * @param maxFiles
   * @param extension
   * @param minSup
   * @param minSeqLen
   * @param maxSeqLen
   * @param gap - the allowed gap between two consequtive instructions.
   * @param inDir
   * @param classLabelFile
   * @param outputFilePath
   * @param idCol
   * @param verbose
   * @throws FileNotFoundException
   */
  private static void functionFrequentSequence(final int maxFiles, final String extension,
      final double minSup, final int minSeqLen, final int maxSeqLen, final int gap, 
      final File inDir, final File classLabelFile, final String outputFilePath,
      final boolean idCol, final int verbose) throws FileNotFoundException {
    
    Map<String, String> classLabels = null;
    if (classLabelFile != null) {
      classLabels = MicrosoftDatasetReaders.readClassLables(classLabelFile);
    }
    
    File[] files = FileUtil.listFiles(extension, inDir);

    List<Binary> binaries = new ArrayList<Binary>(maxFiles);
    // for each sample file 
    for (File f : files) {
      // Extract functions
      boolean includeDBInstructions = true;
      List<Function> functions = AsmParser.parseFunctionTransaction(new FileInputStream(f),
          AsmParser.ExtractionMode.TRANSACTION, AsmMode.OPCODE, includeDBInstructions);
      
      // Map function names to function objects
      Map<String, Function> functionNameMap = new HashMap<String, Function>(functions.size());
      for (Function fn : functions) {
        functionNameMap.put(fn.getName(), fn);
      }
      
      
      // TODO: write the extracted call graph to file, outputFilePath != null.
    }

  }

  /***
   * Extracts frequent sequence feature.
   * @param maxFiles
   * @param extension
   * @param minSup
   * @param minSequenceLength
   * @param maxSequenceLength
   * @param gap
   * @param inDir
   * @param classLabelFile
   * @param outputFilePath
   * @param nameColumn
   * @param verbose
   * @throws IOException
   */
  protected static void binaryFrequentSequence(final int maxFiles, final String extension,
      final double minSup, int minSequenceLength, int maxSequenceLength, int gap, File inDir,
      File classLabelFile, String outputFilePath, boolean nameColumn, int verbose)
          throws IOException {

    Map<String, String> classLabels = null;
    if (classLabelFile != null) {
      classLabels = MicrosoftDatasetReaders.readClassLables(classLabelFile);
    }

    Writer arffFileWritter = new PrintWriter(outputFilePath);

    File[] files = FileUtil.listFiles(extension, inDir);

    List<Binary> binaries = new ArrayList<Binary>(maxFiles);
    // Maps a Sequence object to an index. This index is later used to index the bit
    // representing a particular sequence in a bit vector representation.
    Map<Sequence, Integer> allFreqSequences = new HashMap<Sequence, Integer>();

    int index = 0;
    int countFiles = 0;
    for (File f : files) {
      // Parse the disassembled file to transactional representation.
      // Each transaction consists of single item.

      boolean includeDBInstructions = true;
      List<HashTreeItemset> transactions =
          AsmParser.parseTransaction(new FileInputStream(f), AsmParser.AsmMode.OPCODE,
              includeDBInstructions);
      if (transactions.isEmpty()) {
        System.out.println("EmptyTransactions: " + f.getName());
        continue;
      }
      
      if (countFiles++ == maxFiles) {
        break;
      }
      

      // Main Sequence Mining Algorithm.
      List<Sequence> freqSeq =
          mineFrequentSequence(transactions, minSup, minSequenceLength, maxSequenceLength, gap,
              verbose);

      if (freqSeq.isEmpty()) {
        System.out.println("EmptyFreqSeq: " + f.getName());
      }
      
      // Update allFreqSequences with the newly discovered sequences.
      for (Sequence fs : freqSeq) {
        if (!allFreqSequences.containsKey(fs)) {
          allFreqSequences.put(fs, index++);
        }
      }

      Binary bin = new Binary(f.getName().replaceFirst("[.][^.]+$", ""));
      bin.setFrequentSequences(freqSeq);
      binaries.add(bin);
    }

    writeFrequentSeqToArffFile(classLabelFile, nameColumn, classLabels, arffFileWritter, binaries,
        allFreqSequences);

    arffFileWritter.close();
  }

  private static List<Sequence> mineFrequentSequence(List<HashTreeItemset> transactions, double minSup,
      int minSequenceLength, int maxSequenceLength, int gap, int verbose) {
    SPAMFrequentItemset spamAlgo =
        new SPAMFrequentItemset(minSup, minSequenceLength, maxSequenceLength, gap);
    spamAlgo.setVerboseLevel(verbose);
    return spamAlgo.MineFrequentItemset(transactions);
  }

  private static void writeArffHeader(Map<Sequence, Integer> allFreqSequences, boolean nameColumn,
      File classLabelFile, Writer outFile) throws IOException {
    outFile.write("%1. Title: MS Malware Challenge Frequent sequence feature data set.\n");
    outFile.write("%\n");
    outFile.write("@RELATION freq_sequence_feature.\n");

    if (nameColumn) {
      outFile.write("@ATTRIBUTE id STRING\n");
    }

    for (Map.Entry<Sequence, Integer> me : allFreqSequences.entrySet()) {
      outFile.write("@ATTRIBUTE \"attrib_" + attribName(me.getKey()) + "\" NUMERIC\n");
    }
    if (classLabelFile != null) {
      outFile.write("@ATTRIBUTE class  {1,2,3,4,5,6,7,8,9}\n");
    }
    outFile.write("\n@DATA\n");
    outFile.flush();
  }

  private static void writeArffDataRow(String name, Map<String, String> classLabels, int size,
      BitSet freqSeqBitVector, boolean nameColumn, Writer arffFileWritter) throws IOException {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < size; i++) {
      if (i == 0) {
        if (nameColumn) {
          sb.append("\"" + name + "\"");
          sb.append(",");
        }
      } else {
        sb.append(",");
      }
      sb.append(freqSeqBitVector.get(i) ? "1" : "0");
    }

    if (classLabels != null) {
      String c = classLabels.get(name);
      if (c != null) {
        sb.append("," + c);
      }
    }
    arffFileWritter.write(sb.toString());
    arffFileWritter.write("\n");
    arffFileWritter.flush();
  }

  private static String attribName(Sequence sequence) {
    StringBuilder sb = new StringBuilder();

    for (ItemSet<String> elem : sequence.elements()) {
      HashTreeItemset itmSet = (HashTreeItemset) elem;
      for (String item : itmSet.items()) {
        sb.append(item);
        sb.append("-");
      }
      sb.append("_");
    }

    return sb.toString();
  }

  private static void writeFrequentSeqToArffFile(File classLabelFile, boolean nameColumn,
      Map<String, String> classLabels, Writer arffFileWritter, List<Binary> binaries,
      Map<Sequence, Integer> allFreqSequences) throws IOException {
    // Write the header information for an ARFF file.
    writeArffHeader(allFreqSequences, nameColumn, classLabelFile, arffFileWritter);

    for (int i = 0; i < binaries.size(); i++) {
      Binary bin = binaries.get(i);
      // freqSeqBitVector notes all the frequentSequence indices found in this file.
      BitSet freqSeqBitVector = new BitSet(allFreqSequences.size());
      for (Sequence s : bin.frequentSequencesIterator()) {
        int position = allFreqSequences.get(s);
        freqSeqBitVector.set(position);
      }
      writeArffDataRow(bin.getName(), classLabels, allFreqSequences.size(), freqSeqBitVector,
          nameColumn, arffFileWritter);
    }
  }

}
