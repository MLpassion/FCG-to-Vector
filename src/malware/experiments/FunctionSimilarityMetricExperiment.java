package malware.experiments;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;

import malware.feature.CosineFunctionMatcher;
import malware.feature.EditDistanceFunctionMatcher;
import malware.feature.FeatureExtractor;
import malware.feature.FunctionMatcher;
import malware.feature.HashedNgramBooleanFeatureExtractor;
import malware.feature.HashedNgramFrequencyFeatureExtractor;
import malware.feature.JaccardFunctionMatcher;
import malware.feature.MinHashMatcher;
import malware.parse.AsmParser;
import malware.parse.CallGraph;
import malware.parse.Function;
import malware.parse.AsmParser.AsmMode;
import malware.parse.CallGraph.FunctionVertex;
import malware.parse.CallGraph.FunctionVertex.FunctionType;
import malware.feature.MinHashFeatureExtractor;
import util.CommandLineArguments;
import util.FileUtil;
import util.hash.MurmurHashWrapper;

/***
 * This experiment is aimed at comparing the different function similarity metrics.
 * 
 * @author mehadi
 *
 */
public class FunctionSimilarityMetricExperiment {

  public static void main(String[] args) throws IOException {
    CommandLineArguments cmdArgs = new CommandLineArguments();
    cmdArgs.addOption(true, "-label", true); // Class label file
    cmdArgs.addOption(true, "-in", true); // Input file path
    cmdArgs.addOption(true, "-out", true); // Output file path
    cmdArgs.addOption(true, "-hbits", true); // Hash length in terms number of bits
    cmdArgs.addOption(false, "-ngram_len", true); // Ngram leangth
    cmdArgs.addOption(true, "-mode", true); // opcode | asm
    cmdArgs.addOption(true, "-max_files", true); // max number of files to process.
    cmdArgs.addOption(false, "-norm", false); // normalize to unit vector
    cmdArgs.addOption(true, "-exp", true); // jaccard | cosine | minhash
    cmdArgs.addOption(false, "-num_hashfn", true); // number of hash functions

    if (!cmdArgs.parseCommandLineArgs(args)) {
      System.out.println("Usage:\n\tjava FunctionSimilarityMetricExperiment "
          + " -label class_label_file -in input_file -out output_file -hbits number_hash_bits"
          + " -ngram_len ngram_length -mode (opcode|asm)"
          + " -max_files max_number_of_files_to_process [-norm]\n");
      return;
    }

    String classLabelFile = cmdArgs.getOptionValue("-label");
    String inputFile = cmdArgs.getOptionValue("-in");
    String outputFile = cmdArgs.getOptionValue("-out");
    int numHashBits = Integer.parseInt(cmdArgs.getOptionValue("-hbits"));
    int ngramLength = cmdArgs.getOptionValue("-ngram_len") == null ? 2 : 
      Integer.parseInt(cmdArgs.getOptionValue("-ngram_len"));
    int numHashFunctions = cmdArgs.getOptionValue("-num_hashfn") == null ? 10 :
        Integer.parseInt(cmdArgs.getOptionValue("-num_hashfn"));
    AsmMode asmMode = cmdArgs.getOptionValue("-mode") == null ? AsmMode.OPCODE
        : (cmdArgs.getOptionValue("-mode").equals("asm") ? AsmMode.ASM : AsmMode.OPCODE);
    int maxFiles = Integer.parseInt(cmdArgs.getOptionValue("-max_files"));
    boolean norm = cmdArgs.getOptionValue("-norm") == null ? false : true;
    String exp = cmdArgs.getOptionValue("-exp");

    if (exp.equals("jaccard")) {
      editDistanceVsJaccardSim(inputFile, classLabelFile, outputFile, numHashBits, ngramLength,
          asmMode, maxFiles);

    } else if (exp.equals("cosine")) {
      editDistanceVsCosineSim(inputFile, classLabelFile, outputFile, numHashBits, ngramLength,
          asmMode, maxFiles, norm);
    } else if (exp.equals("minhash")) {
      editDistanceVsMinHashSim(inputFile, classLabelFile, outputFile, numHashBits, ngramLength,
          asmMode, maxFiles, numHashFunctions);
    }
  }

  public static void editDistanceVsMinHashSim(String inputFile, String classLabelFile,
      String outputFile, int numHashBits, int ngramLength, AsmMode asmMode, int maxFiles,
      int numHashFunctions) throws IOException, FileNotFoundException {
    MinHashMatcher minhashMatcher = new MinHashMatcher();

    MinHashFeatureExtractor extractor = new MinHashFeatureExtractor(asmMode, numHashFunctions,
        new Random(Long.getLong("seed", System.nanoTime())), numHashBits, ngramLength);

    editDistanceVsSimilarity(maxFiles, ".asm", new File(inputFile), new File(classLabelFile),
        new PrintWriter(new File(outputFile)), false, true, true, minhashMatcher, extractor);
  }

  public static void editDistanceVsJaccardSim(String inputFile, String classLabelFile,
      String outputFile, int numHashBits, int ngramLength, AsmMode asmMode, int maxFiles)
          throws IOException, FileNotFoundException {
    JaccardFunctionMatcher jacMatcher = new JaccardFunctionMatcher();

    MurmurHashWrapper hashFn =
        new MurmurHashWrapper(Long.getLong("seed", System.nanoTime()).intValue());

    HashedNgramBooleanFeatureExtractor extractor =
        new HashedNgramBooleanFeatureExtractor(numHashBits, ngramLength, asmMode, hashFn);

    editDistanceVsSimilarity(maxFiles, ".asm", new File(inputFile), new File(classLabelFile),
        new PrintWriter(new File(outputFile)), false, true, true, jacMatcher, extractor);
  }

  public static void editDistanceVsCosineSim(String inputFile, String classLabelFile,
      String outputFile, int numHashBits, int ngramLength, AsmMode asmMode, int maxFiles,
      boolean normalizeVector) throws IOException, FileNotFoundException {
    CosineFunctionMatcher cosMatcher = new CosineFunctionMatcher();

    // int numHashBits = 10;
    // int ngramLength = 2;
    // boolean normalizeVector = false;
    // AsmMode asmMode = AsmMode.OPCODE;
    MurmurHashWrapper hashFn =
        new MurmurHashWrapper(Long.getLong("seed", System.nanoTime()).intValue());

    HashedNgramFrequencyFeatureExtractor extractor =
        new HashedNgramFrequencyFeatureExtractor(numHashBits, ngramLength, normalizeVector, asmMode, hashFn);


    editDistanceVsSimilarity(5, ".asm", new File(inputFile), new File(classLabelFile),
        new PrintWriter(new File(outputFile)), false, true, true, cosMatcher, extractor);
  }

  /***
   * Compare the different function similarity metrics.
   * 
   * @param maxFiles
   * @param extension
   * @param inDir
   * @param classLabelFile
   * @param outputFilePath
   * @param idCol
   * @param verbose
   * @throws IOException
   */
  public static void editDistanceVsSimilarity(int maxFiles, String extension, File inDir,
      File classLabelFile, Writer outputFile, boolean idCol, boolean verbose, boolean randomSamples,
      FunctionMatcher matcher2, FeatureExtractor extractor) throws IOException {

    Map<String, String> classLabels = null;
    if (classLabelFile != null) {
      classLabels = malware.data.MicrosoftDatasetReaders.readClassLables(classLabelFile);
    }

    File[] files = FileUtil.listFiles(extension, inDir);

    if (randomSamples) {
      double prob = (double) (maxFiles + 5) / files.length;
      files = FileUtil.listFileRandomSubset(extension, inDir, prob);
    }

    List<CallGraph<Double[]>> callGraphs = new ArrayList<CallGraph<Double[]>>(maxFiles);

    // CosineFunctionMatching cosMatcher = new CosineFunctionMatching();
    // EditDistanceFunctionMatching editMatcher = new EditDistanceFunctionMatching(AsmMode.OPCODE);

    // for each sample file
    int count = 0;
    long totalFunctions = 0;
    for (File f : files) {
      String binaryName = f.getName().replaceFirst("[.][^.]+$", "");
      if (count++ > maxFiles && maxFiles > 0) {
        break;
      }

      if (verbose && (count % 50 == 0)) {
        System.err.printf("%04d files processed.\n", count);
      }

      // Extract functions
      boolean includeDBInstructions = true;
      List<Function> functions = AsmParser.parseFunctionTransaction(new FileInputStream(f),
          AsmParser.ExtractionMode.INSTRUCTION, AsmMode.OPCODE, includeDBInstructions);

      if (functions.isEmpty() || functions.size() > 450) {
        count--;
        continue;
      }
      totalFunctions += functions.size();

      CallGraph<Double[]> binCallGraph = CallGraph.build(functions, extractor, true);
      binCallGraph.setName(binaryName);
      callGraphs.add(binCallGraph);
      if (verbose) {
        System.err.printf("%s vertex=%d\n", binaryName, binCallGraph.vSize());
      }
    }

    EditDistanceFunctionMatcher editMatcher = new EditDistanceFunctionMatcher(AsmMode.OPCODE);

    outputFile.write(String.format("class1,class2,%s,%s\n", editMatcher.getClass().getName(),
        matcher2.getClass().getName()));
    // For each pair of call graphs / binaries
    long progress = 0;
    totalFunctions = totalFunctions * totalFunctions;
    for (int i = 0; i < callGraphs.size(); i++) {
      for (int j = 0; j < callGraphs.size(); j++) {
        if (i == j) {
          continue;
        }

        // For each pair of internal functions
        CallGraph<Double[]> g1 = callGraphs.get(i);
        CallGraph<Double[]> g2 = callGraphs.get(j);
        for (int v : g1.getVertices()) {
          FunctionVertex<Double[]> f1 = g1.getVertex(v);
          if (f1 == null || f1.getType() == FunctionType.External) {
            continue;
          }
          for (int u : g2.getVertices()) {
            FunctionVertex<Double[]> f2 = g1.getVertex(u);
            if (f2 == null || f2.getType() == FunctionType.External) {
              continue;
            }
            progress++;
            if ((totalFunctions / 50) != 0 && progress % (totalFunctions / 50) == 0) {
              System.err.printf("%.0f%%: %d of %d\n", (float) progress / totalFunctions, progress,
                  totalFunctions);
            }

            double sim1 = editMatcher.similarity(f1.getInstructions(), f2.getInstructions());
            double sim2 = matcher2.similarity(f1.getFeatures(), f2.getFeatures());
            matcher2.similarity(f1.getFeatures(), f2.getFeatures());
            if (outputFile != null) {
              outputFile.write(String.format("%s,", classLabels.get(g1.getName())));
              outputFile.write(String.format("%s,", classLabels.get(g2.getName())));
              outputFile.write(String.format("%.5f,", sim1));
              outputFile.write(String.format("%.5f\n", sim2));
            }
          }
        }
      }
    }
  }

}
