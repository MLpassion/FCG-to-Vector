package malware.experiments;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

import ml.data.Attribute;
import ml.data.DataInstance;
import util.CommandLineArguments;
import util.DataReader;
import util.Pair;

public class NaiveKNN {

  public static void main(String[] args) throws FileNotFoundException {
    CommandLineArguments cmdArgs = new CommandLineArguments();
    cmdArgs.addOption(true, "-label", true); // Class label file
    cmdArgs.addOption(true, "-in", true); // Input folder path
    cmdArgs.addOption(true, "-k", true); // Number of neighbours.

    if (!cmdArgs.parseCommandLineArgs(args)) {
      System.out.println("Usage:\n\tjava NaiveKNN "
          + " -in input_folder -label class_label -k num_of_neighbours \n");
      return;
    }

    String inputPath = cmdArgs.getOptionValue("-in");
    String labelPath = cmdArgs.getOptionValue("-label");
    Integer k =
        cmdArgs.getOptionValue("-k") == null ? 5 : Integer.parseInt(cmdArgs.getOptionValue("-k"));

    File inputFile = new File(inputPath);
    if (!inputFile.isFile() || !inputFile.exists()) {
      System.err.println("Input path is not a file or does not exist.");
      return;
    }
    File labelFile = new File(labelPath);
    if (!labelFile.isFile() || !labelFile.exists()) {
      System.err.println("Label path is not a file or does not exist.");
      return;
    }

    List<Pair<String, String>> predictions = naiveKNN(inputPath, k, labelFile);

    double accuracy = SupervisedPerformanceMetric.accuracy(predictions);

    System.out.println("\nAccuracy = " + accuracy);
    System.out.println("Total Number of Instances = " + predictions.size());
    System.out.printf("Confusion Matrix \n%s",
        SupervisedPerformanceMetric.confusionMatrix(predictions));
  }

  private static List<Pair<String, String>> naiveKNN(String inputPath, Integer k, File labelFile)
      throws FileNotFoundException {
    Map<String, String> classLabels = null;
    if (labelFile != null) {
      classLabels = malware.data.MicrosoftDatasetReaders.readClassLables(labelFile);
    }

    int graph1 = 0;
    int graph2 = 1;
    int ged = 2;
    List<Attribute> attributeList = new ArrayList<Attribute>();
    attributeList.add(new Attribute("graph1", graph1, Attribute.Type.ID));
    attributeList.add(new Attribute("graph2", graph2, Attribute.Type.ID));
    attributeList.add(new Attribute("ged", ged, Attribute.Type.CONTINUOUS));

    List<DataInstance> instances = DataReader.readData(inputPath, attributeList, false, true);

    Comparator<Pair<String, Double>> compareOnSecond = new Comparator<Pair<String, Double>>() {
      @Override
      public int compare(Pair<String, Double> o1, Pair<String, Double> o2) {
        return -1 * Double.compare(o1.getSecond(), o2.getSecond());
      }
    };

    HashMap<String, PriorityQueue<Pair<String, Double>>> map =
        new HashMap<String, PriorityQueue<Pair<String, Double>>>();

    for (DataInstance di : instances) {
      PriorityQueue<Pair<String, Double>> q = map.get(di.getAttributeValueAt(graph1));
      if (q == null) {
        q = new PriorityQueue<>(k + 1, compareOnSecond);
        map.put((String) di.getAttributeValueAt(graph1), q);
      }
      q.add(new Pair<String, Double>((String) di.getAttributeValueAt(graph2),
          (Double) di.getAttributeValueAt(ged)));
      if (q.size() > k) {
        Pair<String, Double> removed = q.peek();
        q.poll();
      }
      // Since similarity is symetric.
      q = null;
      q = map.get(di.getAttributeValueAt(graph2));
      if (q == null) {
        q = new PriorityQueue<>(k + 1, compareOnSecond);
        map.put((String) di.getAttributeValueAt(graph2), q);
      }
      q.add(new Pair<String, Double>((String) di.getAttributeValueAt(graph1),
          (Double) di.getAttributeValueAt(ged)));
      if (q.size() > k) {
        Pair<String, Double> removed = q.peek();
        q.poll();
      }
      // Since similarity is symetric.
      q = null;
      q = map.get(di.getAttributeValueAt(graph2));
      if (q == null) {
        q = new PriorityQueue<>(k + 1, compareOnSecond);
        map.put((String) di.getAttributeValueAt(graph2), q);
      }
      q.add(new Pair<String, Double>((String) di.getAttributeValueAt(graph1), 
          (Double) di.getAttributeValueAt(ged)));
      if (q.size() > k) {
        Pair<String, Double> removed = q.peek();
        q.poll();
      }
    }

    List<Pair<String, String>> predictions = new ArrayList<>(map.size());

    for (Map.Entry<String, PriorityQueue<Pair<String, Double>>> entr : map.entrySet()) {
      String g1ClassL = classLabels.get(entr.getKey());
      if (g1ClassL == null) {
        System.err.println("Error: class lable not found for instance " + entr.getKey());
        continue;
      }

      HashMap<String, Integer> classMap = new HashMap<String, Integer>(15);

      String maxClass = null;
      int maxValue = -1;
      for (Pair<String, Double> p : entr.getValue()) {
        String classL = classLabels.get(p.getFirst());
        if (classL == null) {
          System.err.println("Error: class lable not found for instance " + p.getFirst());
          continue;
        }

        Integer count = classMap.get(classL);
        if (count == null) {
          count = 0;
        }
        classMap.put(classL, count + 1);
        if (count + 1 > maxValue) {
          maxClass = classL;
        }
      }

      predictions.add(new Pair<String, String>(g1ClassL, maxClass));
    }

    return predictions;
  }

}
