package malware.experiments;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Comparator;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import malware.feature.CosineFunctionMatcher;
import malware.feature.EditDistanceFunctionMatcher;
import malware.feature.FrequencyJaccardFunctionMatcher;
import malware.feature.FunctionMatcher;
import malware.feature.JaccardFunctionMatcher;
import malware.feature.MinHashMatcher;
import malware.parse.AsmParser.AsmMode;
import malware.parse.CallGraph;
import malware.parse.CallGraph.FunctionVertex;
import malware.parse.CallGraph.FunctionVertex.FunctionType;
import ml.random.GraphState;
import ml.random.SimulatedAnnealing;
import ml.random.State;
import util.CommandLineArguments;
import util.GMLBitSetFeatureReaderWriter;
import util.GMLDoubleArrayFeatureReaderWriter;
import util.GMLFeatureReaderWriter;
import util.GMLInstructuinListFeatureReaderWriter;
import util.GMLLongArrayFeatureReaderWriter;
import util.Pair;
import util.thread.FixedBlockingThreadPoolExecutor;
import util.thread.SynchronizedFileWriter;

public class AllPairSimilarity {
  public static void main(String[] args) throws IOException {
    CommandLineArguments cmdArgs = new CommandLineArguments();
    cmdArgs.addOption(true, "-in", true); // Input folder path .gml files
    cmdArgs.addOption(true, "-out", true); // Output file pathfor result file
    cmdArgs.addOption(false, "-beta", true); // annealed parameter β . It is is the inverse
                                             // temperature used in statistical physics.
                                             // For small values of β almost any move is accepted
                                             // For β → ∞ the process is essentially a downhill move
                                             // in which the SA state will be replaced by the new
                                             // bijective mapping only if the new state gives a
                                             // lower cost.
    cmdArgs.addOption(false, "-coolingRate", true); // rate by which β changes.
                                                    // Takes on the value between [0,1]
    cmdArgs.addOption(false, "-relaxIter", true); // the number of times β changes.
    cmdArgs.addOption(false, "-iter", true); // number of steps before the value of β is updated.
    cmdArgs.addOption(false, "-max_files", true); // max number of files to process.
    cmdArgs.addOption(false, "-files_ext", true); // file extension.
    cmdArgs.addOption(false, "-feat", true); // Feature extractor.
    cmdArgs.addOption(false, "-thread", true); // Number of threads (default = 4).
    cmdArgs.addOption(false, "-ts", true); // rate by which β changes.

    if (!cmdArgs.parseCommandLineArgs(args)) {
      System.out.println("Usage:\n\tjava AllPairSimilarity " + " -in input_folder -out output_file "
          + " -beta beta -coolingRate coolingRate -relaxIter relaxationIteration -iter iterations "
          + " -max_files max_number_of_files_to_process"
          + " [-feat feature_extractor minhash(default)|jaccard|cosine|edit|new_jaccard] "
          + " [-files_ext file_extension_graph_data_file]"
          + " [-ts similarity_threshold to filter before SA. Defualt not used.]\n");
      return;
    }

    String inputFile = cmdArgs.getOptionValue("-in");
    String outputFile = cmdArgs.getOptionValue("-out");
    Double beta = cmdArgs.getOptionValue("-beta") == null ? 4.0
        : Double.parseDouble(cmdArgs.getOptionValue("-beta"));
    Double coolingRate = cmdArgs.getOptionValue("-coolingRate") == null ? 0.2
        : Double.parseDouble(cmdArgs.getOptionValue("-coolingRate"));
    Integer relaxationIteration = cmdArgs.getOptionValue("-relaxIter") == null ? 50
        : Integer.parseInt(cmdArgs.getOptionValue("-relaxIter"));
    Integer iter = cmdArgs.getOptionValue("-iter") == null ? 50
        : Integer.parseInt(cmdArgs.getOptionValue("-iter"));
    String files_ext = cmdArgs.getOptionValue("-files_ext") == null ? ".gml"
        : cmdArgs.getOptionValue("-files_ext");
    Integer max_files = cmdArgs.getOptionValue("-max_files") == null ? -1
        : Integer.parseInt(cmdArgs.getOptionValue("-max_files"));
    String feat =
        cmdArgs.getOptionValue("-feat") == null ? "minhash" : cmdArgs.getOptionValue("-feat");
    int numThreads = cmdArgs.getOptionValue("-thread") == null ? 4
        : Integer.parseInt(cmdArgs.getOptionValue("-thread"));
    Double similarityThreshold = cmdArgs.getOptionValue("-ts") == null ? null
        : Double.parseDouble(cmdArgs.getOptionValue("-ts"));

    File inputDir = new File(inputFile);
    if (!inputDir.isDirectory()) {
      System.err.println("Input path is not a directory.");
      return;
    }
    File outFile = new File(outputFile);
    if (outFile.isDirectory()) {
      System.err.println("Output path is not a file.");
      return;
    }

    if (feat.equals("minhash")) {
      allPairSimilarity(inputDir, outFile, beta, coolingRate, relaxationIteration, iter, files_ext,
          max_files, new MinHashMatcher(), new GMLLongArrayFeatureReaderWriter(), numThreads,
          similarityThreshold);
    } else if (feat.equals("cosine")) {
      allPairSimilarity(inputDir, outFile, beta, coolingRate, relaxationIteration, iter, files_ext,
          max_files, new CosineFunctionMatcher(), new GMLDoubleArrayFeatureReaderWriter(),
          numThreads, similarityThreshold);
    } else if (feat.equals("jaccard")) {
      allPairSimilarity(inputDir, outFile, beta, coolingRate, relaxationIteration, iter, files_ext,
          max_files, new JaccardFunctionMatcher(), new GMLBitSetFeatureReaderWriter(), numThreads,
          similarityThreshold);
    } else if (feat.equals("edit")) {
      allPairSimilarity(inputDir, outFile, beta, coolingRate, relaxationIteration, iter, files_ext,
          max_files, new EditDistanceFunctionMatcher(AsmMode.OPCODE),
          new GMLInstructuinListFeatureReaderWriter(), numThreads, similarityThreshold);
    } else if (feat.equals("new_jaccard")) {
      allPairSimilarity(inputDir, outFile, beta, coolingRate, relaxationIteration, iter, files_ext,
          max_files, new FrequencyJaccardFunctionMatcher(), new GMLDoubleArrayFeatureReaderWriter(),
          numThreads, similarityThreshold);
    } else {
      System.err.printf("Error: the selected feature matcher \"%s\" not available.\n", feat);
      return;
    }
  }

  /***
   * 
   * @param inputDir
   * @param outFile
   * @param beta
   * @param coolingRate
   * @param relaxationIteration
   * @param iter
   * @param files_ext
   * @param max_files
   * @param matcher
   * @param featureReader
   * @param numThreads
   * @param similarityThreshold Optional. If provided, the size of the two graphs will be reduced by
   *        removing pairs of functions/vertices with similarity greater than similarity threshold
   *        before applyting simulated anaeling to approximate GED.
   * @throws IOException
   */
  private static <F> void allPairSimilarity(File inputDir, File outFile, Double beta,
      Double coolingRate, Integer relaxationIteration, Integer iter, String files_ext,
      Integer max_files, FunctionMatcher<F> matcher, GMLFeatureReaderWriter<F> featureReader,
      int numThreads, Double similarityThreshold) throws IOException {
    File[] files = util.FileUtil.listFiles(files_ext, inputDir);
    Random rng = new Random(Long.getLong("seed", System.currentTimeMillis()));
    BufferedWriter out = new BufferedWriter(new FileWriter(outFile));

    if (numThreads == 1) {
      singleThreadAllPairSimilarity(beta, coolingRate, relaxationIteration, iter, max_files,
          matcher, featureReader, files, rng, out, similarityThreshold);
    } else {
      multiThreadAllPairSimilarity(beta, coolingRate, relaxationIteration, iter, max_files, matcher,
          featureReader, files, rng, out, numThreads, similarityThreshold);
    }

    out.close();
  }

  /***
   * Computes the similarity between all pair of malware samples in the input file array.
   * 
   * @param beta simulated anaeling parameter.
   * @param coolingRate simulated anaeling parameter.
   * @param relaxationIteration simulated anaeling parameter.
   * @param iter simulated anaeling parameter.
   * @param max_files maximum number of processed files.
   * @param matcher vertex/function matcher for calculating vertex relabling cost between local
   *        functions.
   * @param featureReader GMLReaderWriter object.
   * @param files array of input files.
   * @param rng pseudo-random number generator.
   * @param out output file path.
   * @param similarityThreshold Optional. If provided, the size of the two graphs will be reduced by
   *        removing pairs of functions/vertices with similarity greater than similarity threshold.
   * @throws IOException
   * @throws FileNotFoundException
   */
  public static <F> void singleThreadAllPairSimilarity(Double beta, Double coolingRate,
      Integer relaxationIteration, Integer iter, Integer max_files, FunctionMatcher<F> matcher,
      GMLFeatureReaderWriter<F> featureReader, File[] files, Random rng, BufferedWriter out,
      Double similarityThreshold) throws IOException, FileNotFoundException {
    out.write(String.format("graph1,graph2,GED\n"));
    for (int i = 0; i < files.length; i++) {
      if (i > max_files && max_files > -1) {
        break;
      }
      CallGraph<F> graphI = util.GMLGraphReader
          .read(new BufferedInputStream(new FileInputStream(files[i])), featureReader);
      graphI.setName(files[i].getName().replaceFirst("[.][^.]+$", ""));
      System.out.printf("Processing file %d\n", i);

      for (int j = i + 1; j < files.length; j++) {
        if (j > max_files && max_files > -1) {
          break;
        }
        CallGraph<F> graphJ = util.GMLGraphReader
            .read(new BufferedInputStream(new FileInputStream(files[j])), featureReader);
        graphJ.setName(files[j].getName().replaceFirst("[.][^.]+$", ""));

        double ged;
        if (similarityThreshold != null) {
          Pair<CallGraph<F>, CallGraph<F>> reducedGraphPair =
              reduceGraphSizes(graphI, graphJ, similarityThreshold, matcher);
          
          System.out.printf("Removed g1 = %d, g2=%d\n", 
              graphI.vSize() - reducedGraphPair.getFirst().vSize(),
              graphJ.vSize() - reducedGraphPair.getSecond().vSize());
          
          if (reducedGraphPair.getFirst().isEmpty() && reducedGraphPair.getSecond().isEmpty()) {
            ged = 0.0;
          } else {
            ged = graphEditDistance(reducedGraphPair.getFirst(), reducedGraphPair.getSecond(), beta,
                coolingRate, relaxationIteration, iter, matcher, rng);
          }
        } else {
          ged = graphEditDistance(graphI, graphJ, beta, coolingRate, relaxationIteration, iter,
              matcher, rng);
        }
        out.write(String.format("%s,%s,%f\n", graphI.getName(), graphJ.getName(), ged));
        System.out.println(String.format("%s,%s,%f\n", graphI.getName(), graphJ.getName(), ged));
      }
    }

    out.flush();
  }

  /***
   * Returns two graphs that are a reduced version of the two input graphs. This reduction is done
   * by similar vertex pairs from btween the two graphs that have similarity >= similarityThreshold.
   * 
   * @param graph1 original graph 1.
   * @param graph2 original graph 2.
   * @param similarityThreshold the similarity threshold
   * @param matcher FunctionMatcher object used for coputing similarity.
   * @return Returns two graphs that are a reduced by removinf by similar vertex pairs between the
   *         two input graphs.
   */
  public static <F> Pair<CallGraph<F>, CallGraph<F>> reduceGraphSizes(CallGraph<F> graph1,
      CallGraph<F> graph2, Double similarityThreshold, FunctionMatcher<F> matcher) {

    PriorityQueue<Pair<Pair<Integer, Integer>, Double>> candidatePairs =
        new PriorityQueue<Pair<Pair<Integer, Integer>, Double>>(graph1.vSize() * graph2.vSize(),
            new Comparator<Pair<Pair<Integer, Integer>, Double>>() {

              @Override
              public int compare(Pair<Pair<Integer, Integer>, Double> o1,
                  Pair<Pair<Integer, Integer>, Double> o2) {
                return -1 * Double.compare(o1.getSecond(), o2.getSecond());
              }

            });

    // Compare all pairs.
    for (int v : graph1.getVertices()) {
      if (graph1.getVertex(v).getType() == FunctionType.External) {
        continue;
      }
      FunctionVertex<F> graph1V = graph1.getVertex(v);
      for (int u : graph2.getVertices()) {
        if (graph2.getVertex(u).getType() == FunctionType.External) {
          continue;
        }

        double sim = matcher.similarity(graph1V.getFeatures(), graph2.getVertex(u).getFeatures());
        if (sim >= similarityThreshold) {
          candidatePairs
              .add(new Pair<Pair<Integer, Integer>, Double>(new Pair<Integer, Integer>(v, u), sim));
        }
      }
    }

    // Remove most similar pairs.
    Set<Integer> removeGraph1 = new HashSet<Integer>((candidatePairs.size() / 2) + 1);
    Set<Integer> removeGraph2 = new HashSet<Integer>((candidatePairs.size() / 2) + 1);
    while (!candidatePairs.isEmpty()) {
      Pair<Pair<Integer, Integer>, Double> elem = candidatePairs.poll();
      int g1V = elem.getFirst().getFirst();
      int g2U = elem.getFirst().getSecond();
      // If not yet removed from both
      if (!removeGraph1.contains(g1V) && !removeGraph2.contains(g2U)) {
        removeGraph1.add(g1V);
        removeGraph2.add(g2U);
      }
    }
    
//    System.out.printf("Removed g1 = %d, g2=%d\n", removeGraph1.size(), removeGraph2.size());
    
    // Reconstruct graph1 without the remove vertices.
    CallGraph<F> reducedGraph1 = cloneGraphExcept(graph1, removeGraph1);

    // Reconstruct graph2 without the remove vertices.
    CallGraph<F> reducedGraph2 = cloneGraphExcept(graph2, removeGraph2);

    return new Pair<CallGraph<F>, CallGraph<F>>(reducedGraph1, reducedGraph2);
  }

  /***
   * Clone the input graph excluding vertices in the removeVertexSet set and edges containing any of
   * the vertices in this set.
   * 
   * @param graph the original graph.
   * @param removeVertexSet the vertex set not to be included in new graph.
   * @return
   */
  public static <F> CallGraph<F> cloneGraphExcept(CallGraph<F> graph,
      Set<Integer> removeVertexSet) {
    CallGraph<F> reducedGraph1 = new CallGraph<F>(graph.vSize() - removeVertexSet.size());
    reducedGraph1.setName(graph.getName());
    for (int v : graph.getVertices()) {
      if (removeVertexSet.contains(v)) {
        continue;
      }
      reducedGraph1.addVertexWithID(v, graph.getVertex(v));
      for (int u : graph.getAdjacent(v)) {
        if (removeVertexSet.contains(u)) {
          continue;
        }
        reducedGraph1.addEdge(v, u, graph.getEdge(v, u));
      }
    }
    return reducedGraph1;
  }

  public static <F> void multiThreadAllPairSimilarity(Double beta, Double coolingRate,
      Integer relaxationIteration, Integer iter, Integer max_files, FunctionMatcher<F> matcher,
      GMLFeatureReaderWriter<F> featureReader, File[] files, Random rng, BufferedWriter out,
      int maxNumActiveThreads, Double similarityThreshold)
          throws IOException, FileNotFoundException {
    SynchronizedFileWriter syncWriter = new SynchronizedFileWriter(out);
    syncWriter.write(String.format("graph1,graph2,GED\n"));


    long keepAliveTime = 240;
    TimeUnit unit = TimeUnit.SECONDS;
    FixedBlockingThreadPoolExecutor threadPoolExecutor = FixedBlockingThreadPoolExecutor
        .threadPoolExecutorFactory(maxNumActiveThreads, keepAliveTime, unit);

    int totalSimilarities = max_files > -1 ? (max_files * (max_files - 1)) / 2
        : (files.length * (files.length - 1)) / 2; // n(n-1)/2
    int similarityCount = 0;

    for (int i = 0; i < files.length; i++) {
      if (i > max_files && max_files > -1) {
        break;
      }
      CallGraph<F> graphI = util.GMLGraphReader
          .read(new BufferedInputStream(new FileInputStream(files[i])), featureReader);
      graphI.setName(files[i].getName().replaceFirst("[.][^.]+$", ""));
      // System.out.printf("Processing file %d\n", i);

      for (int j = i + 1; j < files.length; j++) {
        if (j > max_files && max_files > -1) {
          break;
        }

        if (similarityCount % 100 == 0) {
          System.out.printf("Processed %d of %d\n", similarityCount, totalSimilarities);
        }
        similarityCount++;

        CallGraph<F> graphJ = util.GMLGraphReader
            .read(new BufferedInputStream(new FileInputStream(files[j])), featureReader);
        graphJ.setName(files[j].getName().replaceFirst("[.][^.]+$", ""));

        // Start worker thread if max number of threads have not been used other wise wait for
        // one of the running threads to finish.
        threadPoolExecutor.execute(new PairSimilarityWorker<F>(beta, coolingRate,
            relaxationIteration, iter, max_files, matcher, rng, syncWriter, graphI, graphJ, 
            similarityThreshold));

      }
    }

    // Wait till all threads finish.
    threadPoolExecutor.awaitActiveThreads();

    syncWriter.flush();

    threadPoolExecutor.shutdown();
    try {
      threadPoolExecutor.awaitTermination(60, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }


  /***
   * Runs simulated anaeling to computer the approximate edit distance between the two graphs.
   * 
   * @param graphI the first graph.
   * @param graphJ the second graph
   * @param beta is the annealed parameter. It is is the inverse temperature used in statistical
   *        physics. For small values of β almost any move is accepted in the process. For β → ∞ the
   *        process is essentially a downhill move in which the SA state will be replaced by the new
   *        bijective mapping only if the new state gives a lower cost.
   * @param relaxationIteration the number of times β changes.
   * @param coolingRate rate by which β changes. Takes on the value between [0,1].
   * @param iter is a predefined number of steps before the value of β is increased.
   * @param matcher vertex matcher for calculating vertex relabling cost between local functions.
   * @param rng a pseudo-random number generator.
   * @return Approximate graph edit distance.
   */
  public static <F> double graphEditDistance(CallGraph<F> graphI, CallGraph<F> graphJ, Double beta,
      Double coolingRate, Integer relaxationIteration, Integer iter, FunctionMatcher<F> matcher,
      Random rng) {
    State initialState = GraphState.randomState(graphI, graphJ, matcher, rng);
    SimulatedAnnealing algo = new SimulatedAnnealing();
    State finalState = algo.search(initialState, beta, relaxationIteration, coolingRate, iter, rng);
    return finalState.getCost();
  }


  /***
   * Worker thread for computing graph similarity using simulated annaeling.
   * 
   * @author mehadi
   *
   */
  public static class PairSimilarityWorker<F> implements Runnable {
    Double beta;
    Double coolingRate;
    Integer relaxationIteration;
    Integer iter;
    Integer max_files;
    FunctionMatcher<F> matcher;
    Random rng;
    SynchronizedFileWriter writer;
    CallGraph<F> graphI;
    CallGraph<F> graphJ;
    Double similarityThreshold;


    public PairSimilarityWorker(Double beta, Double coolingRate, Integer relaxationIteration,
        Integer iter, Integer max_files, FunctionMatcher<F> matcher, Random rng,
        SynchronizedFileWriter writer, CallGraph<F> graphI, CallGraph<F> graphJ,
        Double similarityThreshold) {
      super();
      this.beta = beta;
      this.coolingRate = coolingRate;
      this.relaxationIteration = relaxationIteration;
      this.iter = iter;
      this.max_files = max_files;
      this.matcher = matcher;
      this.rng = rng;
      this.writer = writer;
      this.graphI = graphI;
      this.graphJ = graphJ;
      this.similarityThreshold = similarityThreshold;
    }

    @Override
    public void run() {
      double ged;
      if (similarityThreshold != null) {
        Pair<CallGraph<F>, CallGraph<F>> reducedGraphPair =
            reduceGraphSizes(graphI, graphJ, similarityThreshold, matcher);
        if (reducedGraphPair.getFirst().isEmpty() && reducedGraphPair.getSecond().isEmpty()) {
          ged = 0.0;
        } else {
          ged = graphEditDistance(reducedGraphPair.getFirst(), reducedGraphPair.getSecond(), beta,
              coolingRate, relaxationIteration, iter, matcher, rng);
        }
      } else {
        ged = graphEditDistance(graphI, graphJ, beta, coolingRate, relaxationIteration, iter,
            matcher, rng);
      }
      
      try {
        writer.write(String.format("%s,%s,%f\n", graphI.getName(), graphJ.getName(), ged));
        writer.flush();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
