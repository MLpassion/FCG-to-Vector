package malware.experiments;

import java.io.BufferedInputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Random;

import malware.feature.CosineFunctionMatcher;
import malware.feature.EditDistanceFunctionMatcher;
import malware.feature.FrequencyJaccardFunctionMatcher;
import malware.feature.FunctionMatcher;
import malware.feature.JaccardFunctionMatcher;
import malware.feature.MinHashMatcher;
import malware.parse.CallGraph;
import malware.parse.AsmParser.AsmMode;
import util.CommandLineArguments;
import util.GMLBitSetFeatureReaderWriter;
import util.GMLDoubleArrayFeatureReaderWriter;
import util.GMLFeatureReaderWriter;
import util.GMLInstructuinListFeatureReaderWriter;
import util.GMLLongArrayFeatureReaderWriter;
import util.Pair;

public class PairSimilarity {

  public static void main(String[] args) throws FileNotFoundException, IOException {
    CommandLineArguments cmdArgs = new CommandLineArguments();
    cmdArgs.addOption(true, "-in1", true); // Input file1 path .gml file
    cmdArgs.addOption(true, "-in2", true); // Input file2 path .gml file
    cmdArgs.addOption(false, "-beta", true); // annealed parameter β . It is is the inverse
                                             // temperature used in statistical physics.
                                             // For small values of β almost any move is accepted
                                             // For β → ∞ the process is essentially a downhill move
                                             // in which the SA state will be replaced by the new
                                             // bijective mapping only if the new state gives a
                                             // lower cost.
    cmdArgs.addOption(false, "-coolingRate", true); // rate by which β changes.
                                                    // Takes on the value between [0,1]
    cmdArgs.addOption(false, "-relaxIter", true); // the number of times β changes.
    cmdArgs.addOption(false, "-iter", true); // number of steps before the value of β is updated.
    cmdArgs.addOption(false, "-feat", true); // Feature extractor.
    cmdArgs.addOption(false, "-ts", true); // rate by which β changes.

    if (!cmdArgs.parseCommandLineArgs(args)) {
      System.out.println("Usage:\n\tjava PairSimilarity " + " -in1 input_file1 -in1 input_file1 "
          + " -beta beta -coolingRate coolingRate -relaxIter relaxationIteration -iter iterations "
          + " [-feat feature_extractor minhash(default)|jaccard|cosine|edit|new_jaccard] "
          + " [-ts similarity_threshold to filter before SA. Defualt not used.]\n");
      return;
    }

    String inputPath1 = cmdArgs.getOptionValue("-in1");
    String inputPath2 = cmdArgs.getOptionValue("-in2");
    Double beta = cmdArgs.getOptionValue("-beta") == null ? 4.0
        : Double.parseDouble(cmdArgs.getOptionValue("-beta"));
    Double coolingRate = cmdArgs.getOptionValue("-coolingRate") == null ? 0.2
        : Double.parseDouble(cmdArgs.getOptionValue("-coolingRate"));
    Integer relaxationIteration = cmdArgs.getOptionValue("-relaxIter") == null ? 50
        : Integer.parseInt(cmdArgs.getOptionValue("-relaxIter"));
    Integer iter = cmdArgs.getOptionValue("-iter") == null ? 50
        : Integer.parseInt(cmdArgs.getOptionValue("-iter"));
    String feat =
        cmdArgs.getOptionValue("-feat") == null ? "minhash" : cmdArgs.getOptionValue("-feat");
    int numThreads = cmdArgs.getOptionValue("-thread") == null ? 4
        : Integer.parseInt(cmdArgs.getOptionValue("-thread"));
    Double similarityThreshold = cmdArgs.getOptionValue("-ts") == null ? null
        : Double.parseDouble(cmdArgs.getOptionValue("-ts"));

    File inputFile1 = new File(inputPath1);
    if (!inputFile1.exists()) {
      System.err.printf("ERROR: Input file1 '%s' does not exist.\n", inputPath1);
      return;
    }
    File inputFile2 = new File(inputPath2);
    if (inputFile2.isDirectory()) {
      System.err.printf("ERROR: Input file2 '%s'  does not exist.\n", inputPath2);
      return;
    }

    if (feat.equals("minhash")) {
      pairSimilarity(inputFile1, inputFile2, beta, coolingRate, relaxationIteration, iter,
          new MinHashMatcher(), new GMLLongArrayFeatureReaderWriter(), similarityThreshold);
    } else if (feat.equals("cosine")) {
      pairSimilarity(inputFile1, inputFile2, beta, coolingRate, relaxationIteration, iter,
          new CosineFunctionMatcher(), new GMLDoubleArrayFeatureReaderWriter(),
          similarityThreshold);
    } else if (feat.equals("jaccard")) {
      pairSimilarity(inputFile1, inputFile2, beta, coolingRate, relaxationIteration, iter,
          new JaccardFunctionMatcher(), new GMLBitSetFeatureReaderWriter(), similarityThreshold);
    } else if (feat.equals("edit")) {
      pairSimilarity(inputFile1, inputFile2, beta, coolingRate, relaxationIteration, iter,
          new EditDistanceFunctionMatcher(AsmMode.OPCODE),
          new GMLInstructuinListFeatureReaderWriter(), similarityThreshold);
    } else if (feat.equals("new_jaccard")) {
      pairSimilarity(inputFile1, inputFile2, beta, coolingRate, relaxationIteration, iter,
          new FrequencyJaccardFunctionMatcher(), new GMLDoubleArrayFeatureReaderWriter(),
          similarityThreshold);
    } else {
      System.err.printf("Error: the selected feature matcher \"%s\" not available.\n", feat);
      return;
    }
  }


  /***
   * Computes the similarity between a pair of malware samples in the input file array.
   * 
   * 
   * @param file1 input file1.
   * @param file2 input file2.
   * @param beta simulated anaeling parameter.
   * @param coolingRate simulated anaeling parameter.
   * @param relaxationIteration simulated anaeling parameter.
   * @param iter simulated anaeling parameter.
   * @param matcher vertex/function matcher for calculating vertex relabling cost between local
   *        functions.
   * @param featureReader GMLReaderWriter object.
   * @param similarityThreshold Optional. If provided, the size of the two graphs will be reduced by
   *        removing pairs of functions/vertices with similarity greater than similarity threshold.
   * @throws IOException
   * @throws FileNotFoundException
   */
  public static <F> void pairSimilarity(File file1, File file2, Double beta, Double coolingRate,
      Integer relaxationIteration, Integer iter, FunctionMatcher<F> matcher,
      GMLFeatureReaderWriter<F> featureReader, Double similarityThreshold)
          throws IOException, FileNotFoundException {

    Random rng = new Random(Long.getLong("seed", System.currentTimeMillis()));

    CallGraph<F> graphI = util.GMLGraphReader
        .read(new BufferedInputStream(new FileInputStream(file1)), featureReader);
    graphI.setName(file1.getName().replaceFirst("[.][^.]+$", ""));

    CallGraph<F> graphJ = util.GMLGraphReader
        .read(new BufferedInputStream(new FileInputStream(file2)), featureReader);
    graphJ.setName(file2.getName().replaceFirst("[.][^.]+$", ""));

    double ged;
    if (similarityThreshold != null) {
      Pair<CallGraph<F>, CallGraph<F>> reducedGraphPair =
          AllPairSimilarity.reduceGraphSizes(graphI, graphJ, similarityThreshold, matcher);
      if (reducedGraphPair.getFirst().isEmpty() && reducedGraphPair.getSecond().isEmpty()) {
        ged = 0.0;
      } else {
        ged = AllPairSimilarity.graphEditDistance(reducedGraphPair.getFirst(),
          reducedGraphPair.getSecond(), beta, coolingRate, relaxationIteration, iter, matcher, rng);
      }
    } else {
      ged = AllPairSimilarity.graphEditDistance(graphI, graphJ, beta, coolingRate,
          relaxationIteration, iter, matcher, rng);
    }
    System.out.printf("%s,%s,%f\n", graphI.getName(), graphJ.getName(), ged);

  }

}
